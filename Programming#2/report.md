ECS122B Programming Assignment#2 Report

Part#1: DP Optimization and Subset Sum
This problem was quite simple since we already have studied the pseudocode of Subset Sum during the lecture. "unsigned n = weights.size()" correspondss to the number of items n, "unsigned W" given in the parameter corresponds to the weight bound, and "unsigned OPT[n+1][W+1];" corresponds to the creation of memoization table. After creating the memoization table, I assign 0 for when the n = 0, no items yet. 
Only difference in the problem from the lecture slides is that given input weights is using zero-based indexing in this problem, not one-bassed indexing from the lecture slides; thus, my recurrence has "OPT[i][j] = max(OPT[i-1][j], weights[i-1] + OPT[i-1][j - weights[i-1]]);" when the weight bound is not less than the item's weight - instead of weights[i].

Part#2: Improving Auxiliary Space of Subset Sum
My DP table, vector of vector which I return for the output, only contains two rows, just the last row that I calculated and the row I am currently calculating based on the last row. "vector<vector<unsigned> > OPT" cotains two rows as vectors, "vector<unsigned> previous_row;, vector<unsigned> curr_row;" and have "unsigned W" as the weight bound. I am using nested loop, outter loop for x which indicatess how many items will be processed and it's same as i (row) in OPT table from Part#1, and inner loop for weight bound W. Instead of looking into previous row from the DP table in Part#1, I am looking into vector, "previous_row" when calculating the "curr_row". When innerloop finishes iterating which means that item has been computed and before moving on next outerloop iteration, I update the "previous_row" with "curr_row" so that I can compute the next node based on it and this enables not needing the entire DP table since we only look into previous row to compute current row with DP table anyways - thus; it never gets larger than 2 rows. And then when it finishes computing x times, I do not update the previouss node with current node to reflect the values I computed so far with the constraints of x. After calculation, I push two vector, rows, back into the "OPT", the DP table of two rows.

Part#3: Brute-Force Subset Sum
We have learnt to use binary numbers to represent membership in Subset enumeration. I am using using the binary numbers to first find all the possible subsets (power set) of the weights - each outter loop iteration find one possible subse, and with found subset, I check if the sum of the elements is 0. If there is a subset which elements  sum up to 0, then I pass the elements from "vector<unsigned> temp; - I use  it to save elements of subset each time" to "vector<unsigned> indices;" and make the tuple with the vector of the subset, and bool value "bool check" and return it (result = make_tuple(check, indices);). If there isn't one, then I make the tuple with the default vector and bool which is empty vector and false. 
The Brute-force approach here is implemented in when I am finding all possible subsets of weights. First I find size of weights and create outter loop of 2 power to the size of weights (numbers of power set excluding empty set since |S| != 0 anyways) so that I can compare and check all possible members for each subse - "unsigned n = weights.size(); unsigned p_n = pow(2, n);" Then with the inner loop of number of elements in weight and by using the bitwise operator, I check if jth ( inner loop) bit in i(outter loop = counter) is set. If it is then save it into temp vector where I save the elements of subset each time. 

Part#4: Brute-Force Independent Set
As we are looking for the optimal independent set which is the independent set with the maximum number of vertices with using Brute-Force algorithm, we need to find all possible subsets of vertices, find which subset has independent set and finally, choose (return) the subset which has the miximum number of the vertices. For that, I first read all the undirected edges into the 2D array with the size of n (numbers of vertices), a adjacent matrix ("unsigned edge[n][n];") which '1' between two vertices indicates there is edge; otherwise, 0. Since this is undirected graph, I am setting the node in matrix to 1 in both direction, "edge[x][y] = 1; edge[y][x] = 1;". And then same as Part#3, I use bit operator between binary representation of numbers of power set and j th bit (which represents j th vertices) to find all possible subsets of vertices and save each subset to the temp vector. After finding each subset, I check if there's edge between all the vertices in the subset ("if(edge[temp[j]][temp[k]] == 0)"). If not, then the subset is independent set but we need to find the optimal subset; thus, I check and track the maximum size of the subset for every possilbe independent set using "size_t optimal = 0;, 
if(check && optimal < temp.size()){
            optimal = max(optimal, temp.size());
            result = temp;
        }" 
and at the last subset enumeration, I pass the maximum size of subset which is also the independent set to the result and return it.